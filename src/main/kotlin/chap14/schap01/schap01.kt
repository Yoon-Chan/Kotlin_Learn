package chap14.schap01


fun main() {

}


fun c1(){
    /*
    *   코테스트 명세  - 예제는 test/kotlin/chap13.kt에서 볼 수 있다.
    *
    *   코테스트는 여러 명세 스타일을 지원한다. 어떤 스타일을 택하느냐에 따라 코테스트 코드를 구성하는 방법이 달라진다.
    *   여러 스타일을 섞어 쓰거나 AbstractSpec 클래스 또는 AbstractSpec 클래스의 하위 클래스 중 하나인
    *   AbstractStringSpec과 같은 클래스를 구현함으로써 명세 스타일을 만들 수 있다.
    *
    *   StringSpec에서는 테스트에 대한 설명이 들어있는 문자열 뒤에 람다를 추가해서 개별 테스트를 작성한다.
    *   실제 검증 코드는 shouldBe 중위 연산자 함수를 사용하며,  이 함수는 수신 객체로 받은 값과 인자로 받은 값이
    *   일치하지 않으면 예외를 던진다.
    *
    *   WordSpec 클래스를 사용하면 더 복잡한 테스트 레이아웃을 만들 수 있다.
    *   WordSpec을 가장 단순한 형태로 사용하면 테스트를 정의하는 부분에서 2단계로 이뤄진 계층 구조를 만들 수 있다.
    *   should() 호출을 When() 또는 `when`()으로 감싸면 테스트 계층을 3단계로 구성할 수 있다.
    *
    *   테스트 계층을 원하는 만큼 깊게 만들고 싶아면 FunSpec 클래스를 사용할 수 있다.
    *   FunSpec 클래스는 테스트 코드를 test() 함수 호출로 묶는다.
    *   StringSpec과 달리 이 스타일은 Context 블록으로 테스트를 한 그룹으로 묶을 수 있다.
    *
    *
    *   ExpectSpec도 기본적으로 동일하다. 하지만 text() 대신 expect()를 사용하고, 추가로 최상위에 테스트를 위치시키지 못하게 한다.
    *   즉, 모든 테스트는 context() 블록 안에 들어가야 한다.
    *
    *
    *   DescribeSpec은 describe()/context() 블록을 그룹 짓는 데 사용하고, it()은 내부에 테스트를 담기 위해 사용한다.
    *
    *   ShoulSpec은 FunSpec과 비슷한 레이아웃을 만들어낸다. 이 명세는 문맥 블록을 그룹 짓는 데 사용하고, 말단에 테스트 블록을 위치시킨다.
    *   차이가 있다면 구문 차이이다.
    *   비슷한 유형의 명세를 FreeSpec 클래스를 통해 구성할 수 있다. 이 명세 또한 StringSpec과 마찬가지로 문자열에 대한 invoke()를 사용해
    *   테스트를 정의하며, - 연산자를 통해 문맥을 소개한다.
    *
    *
    *   코테스트는 거킨(Gherkin) 언어에서 영감을 얻은 BDD(행동 주도 개발) 명세 스타일도 지원한다.
    *   FeatureSpec에서는 feature 블록에 의해 계층의 루트가 만들어지과, 그 안에는 구체적인 테스트를 구현하는 시나리오 블록이 들어간다.
    *   feature 안에서 여러 시나리오(또는 그룹)를 묶어 그룹을 만들 때도 feature() 호출을 사용한다.
    *
    *   BehaviorSpec 클래스도 비슷한 스타일을 구현하는데 given()/Given(), `when`()/When(), then()/Then() 이라는 함수로 구분된느
    *   세 가지 수준을 제공한다. and()와 And()를 통해 여러 when/then 블록을 묶어서 그룹 수준을 추가할 수도 있다.
    *
    *
    *   마지막으로는 AnnotationSpec이다. 이 스타일은 DSL 같은 테스트 명세를 사용하지 않고
    *   테스트 클래스 메서드에 붙인 @Test 애너테이션에 의존한다. 이 애너테이션은 JUnit 이나 TestNG와 비슷하다.
    *
    * */

}